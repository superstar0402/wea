#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

use crate::bindings::*;

/* automatically generated by rust-bindgen 0.55.1 */
pub const SYSCALL_check_api_level_ID_IN: u32 = 1610613047;
pub const SYSCALL_check_api_level_ID_OUT: u32 = 2415919558;
pub const SYSCALL_halt_ID_IN: u32 = 1610613308;
pub const SYSCALL_halt_ID_OUT: u32 = 2415919629;
pub const SYSCALL_nvm_write_ID_IN: u32 = 1610613631;
pub const SYSCALL_nvm_write_ID_OUT: u32 = 2415920060;
pub const SYSCALL_cx_rng_u8_ID_IN: u32 = 1610613952;
pub const SYSCALL_cx_rng_u8_ID_OUT: u32 = 2415920165;
pub const SYSCALL_cx_rng_ID_IN: u32 = 1610614060;
pub const SYSCALL_cx_rng_ID_OUT: u32 = 2415920487;
pub const SYSCALL_cx_hash_ID_IN: u32 = 1610614587;
pub const SYSCALL_cx_hash_ID_OUT: u32 = 2415921069;
pub const SYSCALL_cx_ripemd160_init_ID_IN: u32 = 1610614911;
pub const SYSCALL_cx_ripemd160_init_ID_OUT: u32 = 2415921400;
pub const SYSCALL_cx_sha224_init_ID_IN: u32 = 1610615131;
pub const SYSCALL_cx_sha224_init_ID_OUT: u32 = 2415921437;
pub const SYSCALL_cx_sha256_init_ID_IN: u32 = 1610615515;
pub const SYSCALL_cx_sha256_init_ID_OUT: u32 = 2415921764;
pub const SYSCALL_cx_hash_sha256_ID_IN: u32 = 1610615596;
pub const SYSCALL_cx_hash_sha256_ID_OUT: u32 = 2415922080;
pub const SYSCALL_cx_sha384_init_ID_IN: u32 = 1610615851;
pub const SYSCALL_cx_sha384_init_ID_OUT: u32 = 2415922351;
pub const SYSCALL_cx_sha512_init_ID_IN: u32 = 1610616257;
pub const SYSCALL_cx_sha512_init_ID_OUT: u32 = 2415922670;
pub const SYSCALL_cx_hash_sha512_ID_IN: u32 = 1610616392;
pub const SYSCALL_cx_hash_sha512_ID_OUT: u32 = 2415922773;
pub const SYSCALL_cx_sha3_init_ID_IN: u32 = 1610616785;
pub const SYSCALL_cx_sha3_init_ID_OUT: u32 = 2415923062;
pub const SYSCALL_cx_keccak_init_ID_IN: u32 = 1610617039;
pub const SYSCALL_cx_keccak_init_ID_OUT: u32 = 2415923416;
pub const SYSCALL_cx_shake128_init_ID_IN: u32 = 1610650377;
pub const SYSCALL_cx_shake128_init_ID_OUT: u32 = 2415956881;
pub const SYSCALL_cx_shake256_init_ID_IN: u32 = 1610650854;
pub const SYSCALL_cx_shake256_init_ID_OUT: u32 = 2415957159;
pub const SYSCALL_cx_sha3_xof_init_ID_IN: u32 = 1610617152;
pub const SYSCALL_cx_sha3_xof_init_ID_OUT: u32 = 2415923680;
pub const SYSCALL_cx_blake2b_init_ID_IN: u32 = 1610617608;
pub const SYSCALL_cx_blake2b_init_ID_OUT: u32 = 2415924121;
pub const SYSCALL_cx_blake2b_init2_ID_IN: u32 = 1610617958;
pub const SYSCALL_cx_blake2b_init2_ID_OUT: u32 = 2415924369;
pub const SYSCALL_cx_groestl_init_ID_IN: u32 = 1610617376;
pub const SYSCALL_cx_groestl_init_ID_OUT: u32 = 2415923779;
pub const SYSCALL_cx_hmac_ripemd160_init_ID_IN: u32 = 1610618319;
pub const SYSCALL_cx_hmac_ripemd160_init_ID_OUT: u32 = 2415924598;
pub const SYSCALL_cx_hmac_sha256_init_ID_IN: u32 = 1610618577;
pub const SYSCALL_cx_hmac_sha256_init_ID_OUT: u32 = 2415924743;
pub const SYSCALL_cx_hmac_sha512_init_ID_IN: u32 = 1610618803;
pub const SYSCALL_cx_hmac_sha512_init_ID_OUT: u32 = 2415925017;
pub const SYSCALL_cx_hmac_ID_IN: u32 = 1610619089;
pub const SYSCALL_cx_hmac_ID_OUT: u32 = 2415925462;
pub const SYSCALL_cx_hmac_sha512_ID_IN: u32 = 1610619343;
pub const SYSCALL_cx_hmac_sha512_ID_OUT: u32 = 2415925630;
pub const SYSCALL_cx_hmac_sha256_ID_IN: u32 = 1610619435;
pub const SYSCALL_cx_hmac_sha256_ID_OUT: u32 = 2415925940;
pub const SYSCALL_cx_pbkdf2_ID_IN: u32 = 1610654252;
pub const SYSCALL_cx_pbkdf2_ID_OUT: u32 = 2415960661;
pub const SYSCALL_cx_des_init_key_ID_IN: u32 = 1610620035;
pub const SYSCALL_cx_des_init_key_ID_OUT: u32 = 2415926349;
pub const SYSCALL_cx_des_iv_ID_IN: u32 = 1610654498;
pub const SYSCALL_cx_des_iv_ID_OUT: u32 = 2415960903;
pub const SYSCALL_cx_des_ID_IN: u32 = 1610620494;
pub const SYSCALL_cx_des_ID_OUT: u32 = 2415927038;
pub const SYSCALL_cx_aes_init_key_ID_IN: u32 = 1610620715;
pub const SYSCALL_cx_aes_init_key_ID_OUT: u32 = 2415927089;
pub const SYSCALL_cx_aes_iv_ID_IN: u32 = 1610654885;
pub const SYSCALL_cx_aes_iv_ID_OUT: u32 = 2415961314;
pub const SYSCALL_cx_aes_ID_IN: u32 = 1610621410;
pub const SYSCALL_cx_aes_ID_OUT: u32 = 2415927612;
pub const SYSCALL_cx_rsa_init_public_key_ID_IN: u32 = 1610621669;
pub const SYSCALL_cx_rsa_init_public_key_ID_OUT: u32 = 2415927947;
pub const SYSCALL_cx_rsa_init_private_key_ID_IN: u32 = 1610621751;
pub const SYSCALL_cx_rsa_init_private_key_ID_OUT: u32 = 2415928259;
pub const SYSCALL_cx_rsa_generate_pair_ID_IN: u32 = 1610622113;
pub const SYSCALL_cx_rsa_generate_pair_ID_OUT: u32 = 2415928573;
pub const SYSCALL_cx_rsa_sign_ID_IN: u32 = 1610622406;
pub const SYSCALL_cx_rsa_sign_ID_OUT: u32 = 2415928819;
pub const SYSCALL_cx_rsa_verify_ID_IN: u32 = 1610622635;
pub const SYSCALL_cx_rsa_verify_ID_OUT: u32 = 2415929011;
pub const SYSCALL_cx_rsa_encrypt_ID_IN: u32 = 1610622938;
pub const SYSCALL_cx_rsa_encrypt_ID_OUT: u32 = 2415929289;
pub const SYSCALL_cx_rsa_decrypt_ID_IN: u32 = 1610623108;
pub const SYSCALL_cx_rsa_decrypt_ID_OUT: u32 = 2415929511;
pub const SYSCALL_cx_ecfp_is_valid_point_ID_IN: u32 = 1610623339;
pub const SYSCALL_cx_ecfp_is_valid_point_ID_OUT: u32 = 2415929601;
pub const SYSCALL_cx_ecfp_is_cryptographic_point_ID_IN: u32 = 1610623715;
pub const SYSCALL_cx_ecfp_is_cryptographic_point_ID_OUT: u32 = 2415930096;
pub const SYSCALL_cx_ecfp_add_point_ID_IN: u32 = 1610623767;
pub const SYSCALL_cx_ecfp_add_point_ID_OUT: u32 = 2415930311;
pub const SYSCALL_cx_ecfp_scalar_mult_ID_IN: u32 = 1610624243;
pub const SYSCALL_cx_ecfp_scalar_mult_ID_OUT: u32 = 2415930595;
pub const SYSCALL_cx_ecfp_init_public_key_ID_IN: u32 = 1610624493;
pub const SYSCALL_cx_ecfp_init_public_key_ID_OUT: u32 = 2415930697;
pub const SYSCALL_cx_ecfp_init_private_key_ID_IN: u32 = 1610624746;
pub const SYSCALL_cx_ecfp_init_private_key_ID_OUT: u32 = 2415930979;
pub const SYSCALL_cx_ecfp_generate_pair_ID_IN: u32 = 1610624814;
pub const SYSCALL_cx_ecfp_generate_pair_ID_OUT: u32 = 2415931252;
pub const SYSCALL_cx_ecfp_generate_pair2_ID_IN: u32 = 1610625055;
pub const SYSCALL_cx_ecfp_generate_pair2_ID_OUT: u32 = 2415931622;
pub const SYSCALL_cx_ecdsa_sign_ID_IN: u32 = 1610627315;
pub const SYSCALL_cx_ecdsa_sign_ID_OUT: u32 = 2415933558;
pub const SYSCALL_cx_ecdsa_verify_ID_IN: u32 = 1610627569;
pub const SYSCALL_cx_ecdsa_verify_ID_OUT: u32 = 2415933927;
pub const SYSCALL_cx_edward_compress_point_ID_IN: u32 = 1610625881;
pub const SYSCALL_cx_edward_compress_point_ID_OUT: u32 = 2415932203;
pub const SYSCALL_cx_edward_decompress_point_ID_IN: u32 = 1610626097;
pub const SYSCALL_cx_edward_decompress_point_ID_OUT: u32 = 2415932618;
pub const SYSCALL_cx_eddsa_get_public_key_ID_IN: u32 = 1610626332;
pub const SYSCALL_cx_eddsa_get_public_key_ID_OUT: u32 = 2415932863;
pub const SYSCALL_cx_eddsa_sign_ID_IN: u32 = 1610626619;
pub const SYSCALL_cx_eddsa_sign_ID_OUT: u32 = 2415933174;
pub const SYSCALL_cx_eddsa_verify_ID_IN: u32 = 1610627018;
pub const SYSCALL_cx_eddsa_verify_ID_OUT: u32 = 2415933217;
pub const SYSCALL_cx_ecschnorr_sign_ID_IN: u32 = 1610625345;
pub const SYSCALL_cx_ecschnorr_sign_ID_OUT: u32 = 2415931722;
pub const SYSCALL_cx_ecschnorr_verify_ID_IN: u32 = 1610625541;
pub const SYSCALL_cx_ecschnorr_verify_ID_OUT: u32 = 2415932151;
pub const SYSCALL_cx_ecdh_ID_IN: u32 = 1610627741;
pub const SYSCALL_cx_ecdh_ID_OUT: u32 = 2415934100;
pub const SYSCALL_cx_crc16_ID_IN: u32 = 1610650104;
pub const SYSCALL_cx_crc16_ID_OUT: u32 = 2415956268;
pub const SYSCALL_cx_crc16_update_ID_IN: u32 = 1610650222;
pub const SYSCALL_cx_crc16_update_ID_OUT: u32 = 2415956715;
pub const SYSCALL_cx_math_cmp_ID_IN: u32 = 1610628443;
pub const SYSCALL_cx_math_cmp_ID_OUT: u32 = 2415934908;
pub const SYSCALL_cx_math_is_zero_ID_IN: u32 = 1610628663;
pub const SYSCALL_cx_math_is_zero_ID_OUT: u32 = 2415935056;
pub const SYSCALL_cx_math_add_ID_IN: u32 = 1610629115;
pub const SYSCALL_cx_math_add_ID_OUT: u32 = 2415935448;
pub const SYSCALL_cx_math_sub_ID_IN: u32 = 1610629279;
pub const SYSCALL_cx_math_sub_ID_OUT: u32 = 2415935517;
pub const SYSCALL_cx_math_mult_ID_IN: u32 = 1610629438;
pub const SYSCALL_cx_math_mult_ID_OUT: u32 = 2415935938;
pub const SYSCALL_cx_math_addm_ID_IN: u32 = 1610629798;
pub const SYSCALL_cx_math_addm_ID_OUT: u32 = 2415936072;
pub const SYSCALL_cx_math_subm_ID_IN: u32 = 1610630013;
pub const SYSCALL_cx_math_subm_ID_OUT: u32 = 2415936480;
pub const SYSCALL_cx_math_multm_ID_IN: u32 = 1610630213;
pub const SYSCALL_cx_math_multm_ID_OUT: u32 = 2415936755;
pub const SYSCALL_cx_math_powm_ID_IN: u32 = 1610630477;
pub const SYSCALL_cx_math_powm_ID_OUT: u32 = 2415936830;
pub const SYSCALL_cx_math_modm_ID_IN: u32 = 1610630725;
pub const SYSCALL_cx_math_modm_ID_OUT: u32 = 2415937164;
pub const SYSCALL_cx_math_invprimem_ID_IN: u32 = 1610631145;
pub const SYSCALL_cx_math_invprimem_ID_OUT: u32 = 2415937305;
pub const SYSCALL_cx_math_invintm_ID_IN: u32 = 1610631212;
pub const SYSCALL_cx_math_invintm_ID_OUT: u32 = 2415937681;
pub const SYSCALL_cx_math_is_prime_ID_IN: u32 = 1610631496;
pub const SYSCALL_cx_math_is_prime_ID_OUT: u32 = 2415938042;
pub const SYSCALL_cx_math_next_prime_ID_IN: u32 = 1610631844;
pub const SYSCALL_cx_math_next_prime_ID_OUT: u32 = 2415938251;
pub const SYSCALL_os_perso_erase_all_ID_IN: u32 = 1610632181;
pub const SYSCALL_os_perso_erase_all_ID_OUT: u32 = 2415938548;
pub const SYSCALL_os_perso_set_pin_ID_IN: u32 = 1610632415;
pub const SYSCALL_os_perso_set_pin_ID_OUT: u32 = 2415938709;
pub const SYSCALL_os_perso_set_current_identity_pin_ID_IN: u32 = 1610632702;
pub const SYSCALL_os_perso_set_current_identity_pin_ID_OUT: u32 = 2415938826;
pub const SYSCALL_os_perso_set_seed_ID_IN: u32 = 1610632892;
pub const SYSCALL_os_perso_set_seed_ID_OUT: u32 = 2415939306;
pub const SYSCALL_os_perso_derive_and_set_seed_ID_IN: u32 = 1610633149;
pub const SYSCALL_os_perso_derive_and_set_seed_ID_OUT: u32 = 2415939535;
pub const SYSCALL_os_perso_set_words_ID_IN: u32 = 1610633240;
pub const SYSCALL_os_perso_set_words_ID_OUT: u32 = 2415939818;
pub const SYSCALL_os_perso_finalize_ID_IN: u32 = 1610633600;
pub const SYSCALL_os_perso_finalize_ID_OUT: u32 = 2415939924;
pub const SYSCALL_os_perso_isonboarded_ID_IN: u32 = 1610653519;
pub const SYSCALL_os_perso_isonboarded_ID_OUT: u32 = 2415959826;
pub const SYSCALL_os_perso_derive_node_bip32_ID_IN: u32 = 1610634170;
pub const SYSCALL_os_perso_derive_node_bip32_ID_OUT: u32 = 2415940382;
pub const SYSCALL_os_perso_derive_node_with_seed_key_ID_IN: u32 = 1610655448;
pub const SYSCALL_os_perso_derive_node_with_seed_key_ID_OUT: u32 = 2415961604;
pub const SYSCALL_os_perso_seed_cookie_ID_IN: u32 = 1610655996;
pub const SYSCALL_os_perso_seed_cookie_ID_OUT: u32 = 2415962231;
pub const SYSCALL_os_endorsement_get_code_hash_ID_IN: u32 = 1610634511;
pub const SYSCALL_os_endorsement_get_code_hash_ID_OUT: u32 = 2415941025;
pub const SYSCALL_os_endorsement_get_public_key_ID_IN: u32 = 1610634995;
pub const SYSCALL_os_endorsement_get_public_key_ID_OUT: u32 = 2415941273;
pub const SYSCALL_os_endorsement_get_public_key_certificate_ID_IN: u32 = 1610635084;
pub const SYSCALL_os_endorsement_get_public_key_certificate_ID_OUT: u32 = 2415941503;
pub const SYSCALL_os_endorsement_key1_get_app_secret_ID_IN: u32 = 1610635356;
pub const SYSCALL_os_endorsement_key1_get_app_secret_ID_OUT: u32 = 2415941728;
pub const SYSCALL_os_endorsement_key1_sign_data_ID_IN: u32 = 1610635736;
pub const SYSCALL_os_endorsement_key1_sign_data_ID_OUT: u32 = 2415941931;
pub const SYSCALL_os_endorsement_key2_derive_sign_data_ID_IN: u32 = 1610635850;
pub const SYSCALL_os_endorsement_key2_derive_sign_data_ID_OUT: u32 = 2415942206;
pub const SYSCALL_os_global_pin_is_validated_ID_IN: u32 = 1610653756;
pub const SYSCALL_os_global_pin_is_validated_ID_OUT: u32 = 2415960184;
pub const SYSCALL_os_global_pin_check_ID_IN: u32 = 1610653954;
pub const SYSCALL_os_global_pin_check_ID_OUT: u32 = 2415960531;
pub const SYSCALL_os_global_pin_invalidate_ID_IN: u32 = 1610636752;
pub const SYSCALL_os_global_pin_invalidate_ID_OUT: u32 = 2415943163;
pub const SYSCALL_os_global_pin_retries_ID_IN: u32 = 1610636889;
pub const SYSCALL_os_global_pin_retries_ID_OUT: u32 = 2415943192;
pub const SYSCALL_os_registry_count_ID_IN: u32 = 1610637120;
pub const SYSCALL_os_registry_count_ID_OUT: u32 = 2415943430;
pub const SYSCALL_os_registry_get_ID_IN: u32 = 1610637413;
pub const SYSCALL_os_registry_get_ID_OUT: u32 = 2415943858;
pub const SYSCALL_os_ux_ID_IN: u32 = 1610638424;
pub const SYSCALL_os_ux_ID_OUT: u32 = 2415944735;
pub const SYSCALL_os_ux_result_ID_IN: u32 = 1610638592;
pub const SYSCALL_os_ux_result_ID_OUT: u32 = 2415945136;
pub const SYSCALL_os_ux_read_parameters_ID_IN: u32 = 1610639015;
pub const SYSCALL_os_ux_read_parameters_ID_OUT: u32 = 2415945387;
pub const SYSCALL_os_lib_call_ID_IN: u32 = 1610639117;
pub const SYSCALL_os_lib_call_ID_OUT: u32 = 2415945564;
pub const SYSCALL_os_lib_end_ID_IN: u32 = 1610639501;
pub const SYSCALL_os_lib_end_ID_OUT: u32 = 2415945736;
pub const SYSCALL_os_lib_throw_ID_IN: u32 = 1610639685;
pub const SYSCALL_os_lib_throw_ID_OUT: u32 = 2415946119;
pub const SYSCALL_os_flags_ID_IN: u32 = 1610639982;
pub const SYSCALL_os_flags_ID_OUT: u32 = 2415946367;
pub const SYSCALL_os_version_ID_IN: u32 = 1610640312;
pub const SYSCALL_os_version_ID_OUT: u32 = 2415946692;
pub const SYSCALL_os_serial_ID_IN: u32 = 1610640563;
pub const SYSCALL_os_serial_ID_OUT: u32 = 2415946966;
pub const SYSCALL_os_seph_features_ID_IN: u32 = 1610641110;
pub const SYSCALL_os_seph_features_ID_OUT: u32 = 2415947332;
pub const SYSCALL_os_seph_version_ID_IN: u32 = 1610641324;
pub const SYSCALL_os_seph_version_ID_OUT: u32 = 2415947613;
pub const SYSCALL_os_setting_get_ID_IN: u32 = 1610641605;
pub const SYSCALL_os_setting_get_ID_OUT: u32 = 2415947951;
pub const SYSCALL_os_setting_set_ID_IN: u32 = 1610641814;
pub const SYSCALL_os_setting_set_ID_OUT: u32 = 2415948197;
pub const SYSCALL_os_get_memory_info_ID_IN: u32 = 1610642019;
pub const SYSCALL_os_get_memory_info_ID_OUT: u32 = 2415948491;
pub const SYSCALL_os_registry_get_tag_ID_IN: u32 = 1610642257;
pub const SYSCALL_os_registry_get_tag_ID_OUT: u32 = 2415948681;
pub const SYSCALL_os_registry_get_current_app_tag_ID_IN: u32 = 1610642644;
pub const SYSCALL_os_registry_get_current_app_tag_ID_OUT: u32 = 2415948935;
pub const SYSCALL_os_customca_verify_ID_IN: u32 = 1610649697;
pub const SYSCALL_os_customca_verify_ID_OUT: u32 = 2415956098;
pub const SYSCALL_os_sched_exec_ID_IN: u32 = 1610652025;
pub const SYSCALL_os_sched_exec_ID_OUT: u32 = 2415958344;
pub const SYSCALL_os_sched_exit_ID_IN: u32 = 1610652350;
pub const SYSCALL_os_sched_exit_ID_OUT: u32 = 2415958750;
pub const SYSCALL_os_sched_is_running_ID_IN: u32 = 1610652634;
pub const SYSCALL_os_sched_is_running_ID_OUT: u32 = 2415958909;
pub const SYSCALL_os_sched_create_ID_IN: u32 = 1610643399;
pub const SYSCALL_os_sched_create_ID_OUT: u32 = 2415949734;
pub const SYSCALL_os_sched_kill_ID_IN: u32 = 1610643672;
pub const SYSCALL_os_sched_kill_ID_OUT: u32 = 2415949885;
pub const SYSCALL_io_seph_send_ID_IN: u32 = 1610646401;
pub const SYSCALL_io_seph_send_ID_OUT: u32 = 2415952877;
pub const SYSCALL_io_seph_is_status_sent_ID_IN: u32 = 1610646715;
pub const SYSCALL_io_seph_is_status_sent_ID_OUT: u32 = 2415952901;
pub const SYSCALL_io_seph_recv_ID_IN: u32 = 1610647012;
pub const SYSCALL_io_seph_recv_ID_OUT: u32 = 2415953399;
pub const SYSCALL_nvm_write_page_ID_IN: u32 = 1610647294;
pub const SYSCALL_nvm_write_page_ID_OUT: u32 = 2415953660;
pub const SYSCALL_try_context_get_ID_IN: u32 = 1610647473;
pub const SYSCALL_try_context_get_ID_OUT: u32 = 2415953698;
pub const SYSCALL_try_context_set_ID_IN: u32 = 1610647669;
pub const SYSCALL_try_context_set_ID_OUT: u32 = 2415953980;
pub const SYSCALL_cx_rng_u32_ID_IN: u32 = 1610648044;
pub const SYSCALL_cx_rng_u32_ID_OUT: u32 = 2415954388;
pub const SYSCALL_os_sched_last_status_ID_IN: u32 = 1610652811;
pub const SYSCALL_os_sched_last_status_ID_OUT: u32 = 2415959149;
pub const SYSCALL_os_sched_yield_ID_IN: u32 = 1610653118;
pub const SYSCALL_os_sched_yield_ID_OUT: u32 = 2415959341;
pub const SYSCALL_os_sched_switch_ID_IN: u32 = 1610653213;
pub const SYSCALL_os_sched_switch_ID_OUT: u32 = 2415959600;
pub const SYSCALL_os_sched_current_task_ID_IN: u32 = 1610648401;
pub const SYSCALL_os_sched_current_task_ID_OUT: u32 = 2415954928;
pub const SYSCALL_os_mpu_protect_ram_ID_IN: u32 = 1610648898;
pub const SYSCALL_os_mpu_protect_ram_ID_OUT: u32 = 2415955328;
pub const SYSCALL_os_mpu_protect_flash_ID_IN: u32 = 1610649335;
pub const SYSCALL_os_mpu_protect_flash_ID_OUT: u32 = 2415955666;
pub const SYSCALL_PARAMETER_ARRAY_MAX_LEN: u32 = 12;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}

extern "C" {
    pub fn longjmp(__jmpb: *mut cty::c_uint, __retval: cty::c_int);
    pub fn setjmp(__jmpb: *mut cty::c_uint) -> cty::c_int;
}
pub type size_t = cty::c_uint;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = cty::c_longlong;
pub type uintmax_t = cty::c_ulonglong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    pub b: APSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
    );
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_APSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for APSR_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    pub b: IPSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
    );
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for IPSR_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    pub b: xPSR_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
    );
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        T: u32,
        IT: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 15u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let IT: u32 = unsafe { ::core::mem::transmute(IT) };
            IT as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for xPSR_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    pub b: CONTROL_Type__bindgen_ty_1,
    pub w: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FPCA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FPCA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        FPCA: u32,
        _reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FPCA: u32 = unsafe { ::core::mem::transmute(FPCA) };
            FPCA as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(w)
        )
    );
}
impl Default for CONTROL_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVIC_Type {
    pub ISER: [u32; 1usize],
    pub RESERVED0: [u32; 31usize],
    pub ICER: [u32; 1usize],
    pub RSERVED1: [u32; 31usize],
    pub ISPR: [u32; 1usize],
    pub RESERVED2: [u32; 31usize],
    pub ICPR: [u32; 1usize],
    pub RESERVED3: [u32; 31usize],
    pub RESERVED4: [u32; 64usize],
    pub IP: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVIC_Type>(),
        800usize,
        concat!("Size of: ", stringify!(NVIC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVIC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVIC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISER as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICER as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RSERVED1 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RSERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISPR as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED2 as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICPR as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED3 as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED4 as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).IP as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IP)
        )
    );
}
impl Default for NVIC_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCB_Type {
    pub CPUID: u32,
    pub ICSR: u32,
    pub VTOR: u32,
    pub AIRCR: u32,
    pub SCR: u32,
    pub CCR: u32,
    pub RESERVED0: [u32; 1usize],
    pub SHP: [u32; 2usize],
    pub SHCSR: u32,
    pub RESERVED1: [u32; 154usize],
    pub SFCR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SCB_Type>(),
        660usize,
        concat!("Size of: ", stringify!(SCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CPUID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).ICSR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ICSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).VTOR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(VTOR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).AIRCR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AIRCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SCR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).RESERVED0 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHP as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHCSR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHCSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).RESERVED1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SFCR as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SFCR)
        )
    );
}
impl Default for SCB_Type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct SCnSCB_Type {
    pub RESERVED0: [u32; 2usize],
    pub ACTLR: u32,
}
#[test]
fn bindgen_test_layout_SCnSCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SCnSCB_Type>(),
        12usize,
        concat!("Size of: ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCnSCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCnSCB_Type>())).RESERVED0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCnSCB_Type>())).ACTLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(ACTLR)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct SysTick_Type {
    pub CTRL: u32,
    pub LOAD: u32,
    pub VAL: u32,
    pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
    assert_eq!(
        ::core::mem::size_of::<SysTick_Type>(),
        16usize,
        concat!("Size of: ", stringify!(SysTick_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SysTick_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SysTick_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).LOAD as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(LOAD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).VAL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CALIB as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CALIB)
        )
    );
    pub fn pic(linked_address: cty::c_uint) -> cty::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apdu_buffer_s {
    pub buf: *mut u8,
    pub len: u16,
}
#[test]
fn bindgen_test_layout_apdu_buffer_s() {
    assert_eq!(
        ::core::mem::size_of::<apdu_buffer_s>(),
        8usize,
        concat!("Size of: ", stringify!(apdu_buffer_s))
    );
    assert_eq!(
        ::core::mem::align_of::<apdu_buffer_s>(),
        4usize,
        concat!("Alignment of ", stringify!(apdu_buffer_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apdu_buffer_s>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(apdu_buffer_s),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<apdu_buffer_s>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(apdu_buffer_s),
            "::",
            stringify!(len)
        )
    );
}
impl Default for apdu_buffer_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type apdu_buffer_t = apdu_buffer_s;
extern "C" {
    pub fn app_main();
    pub fn os_boot();
    pub fn os_memmove(dst: *mut cty::c_void, src: *const cty::c_void, length: cty::c_uint);
    pub fn os_memset(dst: *mut cty::c_void, c: cty::c_uchar, length: cty::c_uint);
    pub fn os_memset4(dst: *mut cty::c_void, initval: cty::c_uint, nbintval: cty::c_uint);
    pub fn os_memcmp(
        buf1: *const cty::c_void,
        buf2: *const cty::c_void,
        length: cty::c_uint,
    ) -> cty::c_char;
    pub fn os_xor(
        dst: *mut cty::c_void,
        src1: *mut cty::c_void,
        src2: *mut cty::c_void,
        length: cty::c_uint,
    );
    pub fn os_secure_memcmp(
        src1: *mut cty::c_void,
        src2: *mut cty::c_void,
        length: cty::c_uint,
    ) -> cty::c_char;
    pub fn patch();
    pub fn check_api_level(apiLevel: cty::c_uint);
    pub fn halt();
    pub fn io_exchange(
        channel_and_flags: cty::c_uchar,
        apdu_buffer: *mut apdu_buffer_t,
        tx_len: cty::c_ushort,
    ) -> cty::c_ushort;
}








pub type io_apdu_media_t = cty::c_uint;
extern "C" {
    pub static mut G_io_usb_ep_buffer: [cty::c_uchar; 64usize];
    pub fn io_event(channel: cty::c_uchar) -> cty::c_uchar;
    pub fn io_timeout(last_timeout: cty::c_ushort) -> cty::c_ushort;
    pub fn nvm_write(dst_adr: *mut cty::c_void, src_adr: *mut cty::c_void, src_len: cty::c_uint);
    pub fn nvm_write_os(dst_adr: *mut cty::c_void, src_adr: *mut cty::c_void, src_len: cty::c_uint);
    pub fn nvm_write_page(page_adr: *mut cty::c_uchar);
    pub fn svc_nvm_write_page(page_adr: *mut cty::c_uchar);
    pub fn try_context_get() -> *mut try_context_t;
    pub fn svc_try_context_get() -> *mut try_context_t;
    pub fn try_context_set(context: *mut try_context_t) -> *mut try_context_t;
    pub fn svc_try_context_set(tryctx: *mut try_context_t) -> *mut try_context_t;
    pub fn os_longjmp(exception: cty::c_uint);
}
pub type uint64bits_t = u64;
extern "C" {
    pub fn cx_rng_u8() -> cty::c_uchar;
}
pub type cx_rng_u32_range_randfunc_t = ::core::option::Option<unsafe extern "C" fn() -> u32>;
extern "C" {
    pub fn cx_rng_u32_range_func(a: u32, b: u32, randfunc: cx_rng_u32_range_randfunc_t) -> u32;
    pub fn cx_rng_u32_range(a: u32, b: u32) -> u32;
    pub fn cx_rng_u32() -> cty::c_uint;
    pub fn svc_cx_rng_u32() -> cty::c_uint;
    pub fn cx_rng(buffer: *mut cty::c_uchar, len: cty::c_uint) -> *mut cty::c_uchar;
}












pub type cx_md_e = cty::c_uint;
pub use self::cx_md_e as cx_md_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hash_header_s {
    pub algo: cx_md_t,
    pub counter: cty::c_uint,
}
#[test]
fn bindgen_test_layout_cx_hash_header_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_hash_header_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_header_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_header_s>())).algo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_header_s>())).counter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(counter)
        )
    );
}
impl Default for cx_hash_header_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_hash_t = cx_hash_header_s;
extern "C" {
    pub fn cx_hash(
        hash: *mut cx_hash_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ripemd160_s {
    pub header: cx_hash_header_s,
    pub blen: cty::c_uint,
    pub block: [cty::c_uchar; 64usize],
    pub acc: [cty::c_uchar; 20usize],
}
#[test]
fn bindgen_test_layout_cx_ripemd160_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ripemd160_s>(),
        96usize,
        concat!("Size of: ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ripemd160_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).acc as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_ripemd160_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_ripemd160_t = cx_ripemd160_s;
extern "C" {
    pub fn cx_ripemd160_init(hash: *mut cx_ripemd160_t) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha256_s {
    pub header: cx_hash_header_s,
    pub blen: cty::c_uint,
    pub block: [cty::c_uchar; 64usize],
    pub acc: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cx_sha256_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha256_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha256_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).acc as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha256_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_sha256_t = cx_sha256_s;
extern "C" {
    pub fn cx_sha224_init(hash: *mut cx_sha256_t) -> cty::c_int;
    pub fn cx_sha256_init(hash: *mut cx_sha256_t) -> cty::c_int;
    pub fn cx_hash_sha256(
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha3_s {
    pub header: cx_hash_header_s,
    pub output_size: cty::c_uint,
    pub block_size: cty::c_uint,
    pub blen: cty::c_uint,
    pub block: [cty::c_uchar; 200usize],
    pub acc: [uint64bits_t; 25usize],
}
#[test]
fn bindgen_test_layout_cx_sha3_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha3_s>(),
        424usize,
        concat!("Size of: ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha3_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).output_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).block_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).blen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).block as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).acc as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha3_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_sha3_t = cx_sha3_s;
extern "C" {
    pub fn cx_sha3_init(hash: *mut cx_sha3_t, size: cty::c_uint) -> cty::c_int;
    pub fn cx_keccak_init(hash: *mut cx_sha3_t, size: cty::c_uint) -> cty::c_int;
    pub fn cx_shake128_init(hash: *mut cx_sha3_t, out_size: cty::c_uint) -> cty::c_int;
    pub fn cx_shake256_init(hash: *mut cx_sha3_t, out_size: cty::c_uint) -> cty::c_int;
    pub fn cx_sha3_xof_init(
        hash: *mut cx_sha3_t,
        size: cty::c_uint,
        out_length: cty::c_uint,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha512_s {
    pub header: cx_hash_header_s,
    pub blen: cty::c_uint,
    pub block: [cty::c_uchar; 128usize],
    pub acc: [cty::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cx_sha512_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha512_s>(),
        204usize,
        concat!("Size of: ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha512_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).acc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha512_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_sha512_t = cx_sha512_s;
extern "C" {
    pub fn cx_sha384_init(hash: *mut cx_sha512_t) -> cty::c_int;
    pub fn cx_sha512_init(hash: *mut cx_sha512_t) -> cty::c_int;
    pub fn cx_hash_sha512(
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}





pub type blake2b_constant = cty::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blake2b_state__ {
    pub h: [u64; 8usize],
    pub t: [u64; 2usize],
    pub f: [u64; 2usize],
    pub buf: [u8; 128usize],
    pub buflen: size_t,
    pub outlen: size_t,
    pub last_node: u8,
}
#[test]
fn bindgen_test_layout_blake2b_state__() {
    assert_eq!(
        ::core::mem::size_of::<blake2b_state__>(),
        240usize,
        concat!("Size of: ", stringify!(blake2b_state__))
    );
    assert_eq!(
        ::core::mem::align_of::<blake2b_state__>(),
        8usize,
        concat!("Alignment of ", stringify!(blake2b_state__))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).t as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).f as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).buf as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).buflen as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).outlen as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(outlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).last_node as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(last_node)
        )
    );
}
impl Default for blake2b_state__ {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type blake2b_state = blake2b_state__;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_blake2b_s {
    pub header: cx_hash_header_s,
    pub output_size: cty::c_uint,
    pub ctx: blake2b_state__,
}
#[test]
fn bindgen_test_layout_cx_blake2b_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_blake2b_s>(),
        256usize,
        concat!("Size of: ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_blake2b_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).output_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).ctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for cx_blake2b_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_blake2b_t = cx_blake2b_s;
extern "C" {
    pub fn cx_blake2b_init(hash: *mut cx_blake2b_t, out_len: cty::c_uint) -> cty::c_int;
    pub fn cx_blake2b_init2(
        hash: *mut cx_blake2b_t,
        out_len: cty::c_uint,
        salt: *mut cty::c_uchar,
        salt_len: cty::c_uint,
        perso: *mut cty::c_uchar,
        perso_len: cty::c_uint,
    ) -> cty::c_int;
}
pub type BitSequence = cty::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hashState_s {
    pub chaining: [[u8; 16usize]; 8usize],
    pub block_counter: u64,
    pub hashlen: cty::c_uint,
    pub buffer: [BitSequence; 128usize],
    pub buf_ptr: cty::c_uint,
    pub columns: cty::c_uint,
    pub rounds: cty::c_uint,
    pub statesize: cty::c_uint,
}
#[test]
fn bindgen_test_layout_hashState_s() {
    assert_eq!(
        ::core::mem::size_of::<hashState_s>(),
        288usize,
        concat!("Size of: ", stringify!(hashState_s))
    );
    assert_eq!(
        ::core::mem::align_of::<hashState_s>(),
        8usize,
        concat!("Alignment of ", stringify!(hashState_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).chaining as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(chaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).block_counter as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(block_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).hashlen as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(hashlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).buffer as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).buf_ptr as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).columns as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).rounds as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(rounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).statesize as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(statesize)
        )
    );
}
impl Default for hashState_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type hashState = hashState_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_groestl_s {
    pub header: cx_hash_header_s,
    pub output_size: cty::c_uint,
    pub ctx: hashState_s,
}
#[test]
fn bindgen_test_layout_cx_groestl_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_groestl_s>(),
        304usize,
        concat!("Size of: ", stringify!(cx_groestl_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_groestl_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_groestl_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_groestl_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_groestl_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_groestl_s>())).output_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_groestl_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_groestl_s>())).ctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_groestl_s),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for cx_groestl_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_groestl_t = cx_groestl_s;
extern "C" {
    pub fn cx_groestl_init(hash: *mut cx_groestl_t, size: cty::c_uint) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cx_hash_for_hmac_ctx {
    pub header: cx_hash_t,
    pub sha256: cx_sha256_t,
    pub sha512: cx_sha512_t,
    pub ripemd160: cx_ripemd160_t,
    _bindgen_union_align: [u32; 51usize],
}
#[test]
fn bindgen_test_layout_cx_hash_for_hmac_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cx_hash_for_hmac_ctx>(),
        204usize,
        concat!("Size of: ", stringify!(cx_hash_for_hmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_for_hmac_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_for_hmac_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).sha256 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(sha256)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).sha512 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(sha512)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).ripemd160 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(ripemd160)
        )
    );
}
impl Default for cx_hash_for_hmac_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hmac_ctx {
    pub hash_ctx: cx_hash_for_hmac_ctx,
    pub key: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_cx_hmac_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_ctx>(),
        332usize,
        concat!("Size of: ", stringify!(cx_hmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_ctx>())).hash_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ctx),
            "::",
            stringify!(hash_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_ctx>())).key as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ctx),
            "::",
            stringify!(key)
        )
    );
}
impl Default for cx_hmac_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_hmac_t = cx_hmac_ctx;
pub type cx_hmac_ripemd160_t = cx_hmac_ctx;
pub type cx_hmac_sha256_t = cx_hmac_ctx;
pub type cx_hmac_sha512_t = cx_hmac_ctx;
extern "C" {
    pub fn cx_hmac_ripemd160_init(
        hmac: *mut cx_hmac_ripemd160_t,
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_hmac_sha256_init(
        hmac: *mut cx_hmac_sha256_t,
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_hmac_sha512_init(
        hmac: *mut cx_hmac_sha512_t,
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_hmac(
        hmac: *mut cx_hmac_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        mac: *mut cty::c_uchar,
        mac_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_hmac_sha512(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        mac: *mut cty::c_uchar,
        mac_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_hmac_sha256(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        mac: *mut cty::c_uchar,
        mac_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_pbkdf2(
        md_type: cx_md_t,
        password: *const cty::c_uchar,
        passwordlen: cty::c_ushort,
        salt: *mut cty::c_uchar,
        saltlen: cty::c_ushort,
        iterations: cty::c_uint,
        out: *mut cty::c_uchar,
        outLength: cty::c_uint,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cx_des_key_s {
    pub size: cty::c_uchar,
    pub keys: [cty::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_cx_des_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_des_key_s>(),
        17usize,
        concat!("Size of: ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_des_key_s>(),
        1usize,
        concat!("Alignment of ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_des_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_des_key_s>())).keys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(keys)
        )
    );
}
pub type cx_des_key_t = cx_des_key_s;
extern "C" {
    pub fn cx_des_init_key(
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        key: *mut cx_des_key_t,
    ) -> cty::c_int;
    pub fn cx_des_iv(
        key: *const cx_des_key_t,
        mode: cty::c_int,
        iv: *mut cty::c_uchar,
        iv_len: cty::c_uint,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_des(
        key: *const cx_des_key_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cx_aes_key_s {
    pub size: cty::c_uint,
    pub keys: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cx_aes_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_aes_key_s>(),
        36usize,
        concat!("Size of: ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_aes_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_aes_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_aes_key_s>())).keys as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(keys)
        )
    );
}
pub type cx_aes_key_t = cx_aes_key_s;
extern "C" {
    pub fn cx_aes_init_key(
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        key: *mut cx_aes_key_t,
    ) -> cty::c_int;
    pub fn cx_aes_iv(
        key: *const cx_aes_key_t,
        mode: cty::c_int,
        iv: *mut cty::c_uchar,
        iv_len: cty::c_uint,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_aes(
        key: *const cx_aes_key_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cx_rsa_public_key_s {
    pub size: cty::c_uint,
    pub e: [cty::c_uchar; 4usize],
    pub n: [cty::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_public_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_rsa_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cx_rsa_private_key_s {
    pub size: cty::c_uint,
    pub d: [cty::c_uchar; 1usize],
    pub n: [cty::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_private_key_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_rsa_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_private_key_s>())).n as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
pub type cx_rsa_public_key_t = cx_rsa_public_key_s;
pub type cx_rsa_private_key_t = cx_rsa_private_key_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_1024_public_key_s {
    pub size: cty::c_uint,
    pub e: [cty::c_uchar; 4usize],
    pub n: [cty::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_1024_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_1024_public_key_s>(),
        136usize,
        concat!("Size of: ", stringify!(cx_rsa_1024_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_1024_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_1024_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_1024_public_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_1024_private_key_s {
    pub size: cty::c_uint,
    pub d: [cty::c_uchar; 128usize],
    pub n: [cty::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_1024_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_1024_private_key_s>(),
        260usize,
        concat!("Size of: ", stringify!(cx_rsa_1024_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_1024_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_1024_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_private_key_s>())).n as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_1024_private_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_rsa_1024_public_key_t = cx_rsa_1024_public_key_s;
pub type cx_rsa_1024_private_key_t = cx_rsa_1024_private_key_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_2048_public_key_s {
    pub size: cty::c_uint,
    pub e: [cty::c_uchar; 4usize],
    pub n: [cty::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_2048_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_2048_public_key_s>(),
        264usize,
        concat!("Size of: ", stringify!(cx_rsa_2048_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_2048_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_2048_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_2048_public_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_2048_private_key_s {
    pub size: cty::c_uint,
    pub d: [cty::c_uchar; 256usize],
    pub n: [cty::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_2048_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_2048_private_key_s>(),
        516usize,
        concat!("Size of: ", stringify!(cx_rsa_2048_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_2048_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_2048_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_private_key_s>())).n as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_2048_private_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_rsa_2048_public_key_t = cx_rsa_2048_public_key_s;
pub type cx_rsa_2048_private_key_t = cx_rsa_2048_private_key_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_3072_public_key_s {
    pub size: cty::c_uint,
    pub e: [cty::c_uchar; 4usize],
    pub n: [cty::c_uchar; 384usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_3072_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_3072_public_key_s>(),
        392usize,
        concat!("Size of: ", stringify!(cx_rsa_3072_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_3072_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_3072_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_3072_public_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_3072_private_key_s {
    pub size: cty::c_uint,
    pub d: [cty::c_uchar; 384usize],
    pub n: [cty::c_uchar; 384usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_3072_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_3072_private_key_s>(),
        772usize,
        concat!("Size of: ", stringify!(cx_rsa_3072_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_3072_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_3072_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_private_key_s>())).n as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_3072_private_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_rsa_3072_public_key_t = cx_rsa_3072_public_key_s;
pub type cx_rsa_3072_private_key_t = cx_rsa_3072_private_key_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_4096_public_key_s {
    pub size: cty::c_uint,
    pub e: [cty::c_uchar; 4usize],
    pub n: [cty::c_uchar; 512usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_4096_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_4096_public_key_s>(),
        520usize,
        concat!("Size of: ", stringify!(cx_rsa_4096_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_4096_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_4096_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_4096_public_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_4096_private_key_s {
    pub size: cty::c_uint,
    pub d: [cty::c_uchar; 512usize],
    pub n: [cty::c_uchar; 512usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_4096_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_4096_private_key_s>(),
        1028usize,
        concat!("Size of: ", stringify!(cx_rsa_4096_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_4096_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_4096_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_private_key_s>())).n as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
impl Default for cx_rsa_4096_private_key_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cx_rsa_4096_public_key_t = cx_rsa_4096_public_key_s;
pub type cx_rsa_4096_private_key_t = cx_rsa_4096_private_key_s;
extern "C" {
    pub fn cx_rsa_init_public_key(
        exponent: *const cty::c_uchar,
        exponent_len: cty::c_uint,
        modulus: *const cty::c_uchar,
        modulus_len: cty::c_uint,
        key: *mut cx_rsa_public_key_t,
    ) -> cty::c_int;
    pub fn cx_rsa_init_private_key(
        exponent: *const cty::c_uchar,
        exponent_len: cty::c_uint,
        modulus: *const cty::c_uchar,
        modulus_len: cty::c_uint,
        key: *mut cx_rsa_private_key_t,
    ) -> cty::c_int;
    pub fn cx_rsa_generate_pair(
        modulus_len: cty::c_uint,
        public_key: *mut cx_rsa_public_key_t,
        private_key: *mut cx_rsa_private_key_t,
        pub_exponent: *const cty::c_uchar,
        exponent_len: cty::c_uint,
        externalPQ: *const cty::c_uchar,
    ) -> cty::c_int;
    pub fn cx_rsa_sign(
        key: *const cx_rsa_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_rsa_verify(
        key: *const cx_rsa_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_rsa_encrypt(
        key: *const cx_rsa_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        mesg: *const cty::c_uchar,
        mesg_len: cty::c_uint,
        enc: *mut cty::c_uchar,
        enc_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_rsa_decrypt(
        key: *const cx_rsa_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        mesg: *const cty::c_uchar,
        mesg_len: cty::c_uint,
        dec: *mut cty::c_uchar,
        dec_len: cty::c_uint,
    ) -> cty::c_int;
}
























extern "C" {
    pub fn cx_ecfp_is_valid_point(
        curve: cx_curve_t,
        P: *const cty::c_uchar,
        P_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecfp_is_cryptographic_point(
        curve: cx_curve_t,
        P: *const cty::c_uchar,
        P_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecfp_add_point(
        curve: cx_curve_t,
        R: *mut cty::c_uchar,
        P: *const cty::c_uchar,
        Q: *const cty::c_uchar,
        X_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecfp_scalar_mult(
        curve: cx_curve_t,
        P: *mut cty::c_uchar,
        P_len: cty::c_uint,
        k: *const cty::c_uchar,
        k_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecfp_init_public_key(
        curve: cx_curve_t,
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        key: *mut cx_ecfp_public_key_t,
    ) -> cty::c_int;
    pub fn cx_ecfp_init_private_key(
        curve: cx_curve_t,
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        pvkey: *mut cx_ecfp_private_key_t,
    ) -> cty::c_int;
    pub fn cx_ecfp_generate_pair(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: cty::c_int,
    ) -> cty::c_int;
    pub fn cx_ecfp_generate_pair2(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: cty::c_int,
        hashID: cx_md_t,
    ) -> cty::c_int;
    pub fn cx_ecdsa_sign(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
        info: *mut cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecdsa_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecschnorr_sign(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        msg: *const cty::c_uchar,
        msg_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
        info: *mut cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecschnorr_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        msg: *const cty::c_uchar,
        msg_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_edward_compress_point(curve: cx_curve_t, P: *mut cty::c_uchar, P_len: cty::c_uint);
    pub fn cx_edward_decompress_point(curve: cx_curve_t, P: *mut cty::c_uchar, P_len: cty::c_uint);
    pub fn cx_eddsa_get_public_key(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        pukey: *mut cx_ecfp_public_key_t,
        a: *mut cty::c_uchar,
        a_len: cty::c_uint,
        h: *mut cty::c_uchar,
        h_len: cty::c_uint,
    );
    pub fn cx_eddsa_sign(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        ctx: *const cty::c_uchar,
        ctx_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
        info: *mut cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_eddsa_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        ctx: *const cty::c_uchar,
        ctx_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_ecdh(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        P: *const cty::c_uchar,
        P_len: cty::c_uint,
        secret: *mut cty::c_uchar,
        secret_len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_crc16(buffer: *const cty::c_void, len: size_t) -> cty::c_ushort;
    pub fn cx_crc16_update(
        crc: cty::c_ushort,
        buffer: *const cty::c_void,
        len: size_t,
    ) -> cty::c_ushort;
    pub fn cx_math_cmp(
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_math_is_zero(a: *const cty::c_uchar, len: cty::c_uint) -> cty::c_int;
    pub fn cx_math_add(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_math_sub(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    ) -> cty::c_int;
    pub fn cx_math_mult(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    );
    pub fn cx_math_addm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
    pub fn cx_math_subm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
    pub fn cx_math_multm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
    pub fn cx_math_powm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        e: *const cty::c_uchar,
        len_e: cty::c_uint,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
    pub fn cx_math_modm(
        v: *mut cty::c_uchar,
        len_v: cty::c_uint,
        m: *const cty::c_uchar,
        len_m: cty::c_uint,
    );
    pub fn cx_math_invprimem(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
    pub fn cx_math_invintm(
        r: *mut cty::c_uchar,
        a: cty::c_ulong,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
    pub fn cx_math_is_prime(p: *const cty::c_uchar, len: cty::c_uint) -> cty::c_int;
    pub fn cx_math_next_prime(n: *mut cty::c_uchar, len: cty::c_uint);
    pub fn cx_selftest() -> cty::c_int;
}







































pub type bolos_ux_e = cty::c_uint;
pub use self::bolos_ux_e as bolos_ux_t;
pub type bolos_bool_t = cty::c_char;
pub type bolos_task_status_t = cty::c_uchar;
pub type appmain_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct application_s {
    pub nvram_begin: *mut cty::c_uchar,
    pub nvram_end: *mut cty::c_uchar,
    pub main: appmain_t,
    pub flags: cty::c_uint,
    pub code_length: cty::c_uint,
    pub data_length: cty::c_uint,
    pub params_length: cty::c_uint,
    pub sha256_code_data: [cty::c_uchar; 32usize],
    pub sha256_full: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_application_s() {
    assert_eq!(
        ::core::mem::size_of::<application_s>(),
        92usize,
        concat!("Size of: ", stringify!(application_s))
    );
    assert_eq!(
        ::core::mem::align_of::<application_s>(),
        4usize,
        concat!("Alignment of ", stringify!(application_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).nvram_begin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).nvram_end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).main as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).code_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(code_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).data_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(data_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).params_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(params_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).sha256_code_data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_code_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).sha256_full as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_full)
        )
    );
}
impl Default for application_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type application_t = application_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s {
    pub ux_id: bolos_ux_t,
    pub len: cty::c_uint,
    pub u: bolos_ux_params_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bolos_ux_params_s__bindgen_ty_1 {
    pub boot_unsafe: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1,
    pub appexitb: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2,
    pub appdel: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3,
    pub appadd: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4,
    pub upgrade: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5,
    pub ux_not_signed: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6,
    pub run_app: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7,
    pub customca_key: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8,
    pub foreign_key: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9,
    pub reset_customca: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10,
    pub setup_customca: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11,
    pub keyboard: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12,
    pub validate_pin: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13,
    pub pin_keyboard: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14,
    pub status_bar: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15,
    pub loader: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16,
    pub onboard: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17,
    pub boot_delay: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18,
    pub pairing_request: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19,
    _bindgen_union_align: [u32; 36usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1 {
    pub currently_onboarded: cty::c_uint,
    pub hash: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>()))
                .currently_onboarded as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(currently_onboarded)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>())).hash
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2 {
    pub app_idx: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(app_idx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3 {
    pub app_idx: cty::c_uint,
    pub appentry: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>())).appentry
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(appentry)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4 {
    pub app_idx: cty::c_uint,
    pub appentry: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>())).appentry
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(appentry)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5 {
    pub app_idx: cty::c_uint,
    pub upgrade: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>())).upgrade
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(upgrade)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6 {
    pub ux_app: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6>(),
        92usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6>())).ux_app
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ux_app)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7 {
    pub app_idx: cty::c_uint,
    pub app: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>())).app
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(app)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8 {
    pub name: [cty::c_char; 65usize],
    pub public: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>())).name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>())).public
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(public)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9 {
    pub host_pubkey: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9>(),
        76usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9>())).host_pubkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(host_pubkey)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10 {
    pub name: [cty::c_char; 65usize],
    pub public: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>())).name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>())).public
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(public)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11 {
    pub name: [cty::c_char; 65usize],
    pub public: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>())).name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>())).public
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(public)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12 {
    pub keycode: cty::c_uint,
    pub mode: cty::c_uint,
    pub entered_text: [cty::c_char; 33usize],
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>(),
        44usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>())).keycode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>())).mode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>())).entered_text
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(entered_text)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13 {
    pub cancellable: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13>())).cancellable
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(cancellable)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14 {
    pub keycode: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14>())).keycode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(keycode)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15 {
    pub fgcolor: cty::c_uint,
    pub bgcolor: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>())).fgcolor
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(fgcolor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>())).bgcolor
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(bgcolor)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16 {
    pub x: cty::c_uint,
    pub y: cty::c_uint,
    pub width: cty::c_uint,
    pub height: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).x
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).y
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).width
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).height
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17 {
    pub id: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17>())).id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18 {
    pub percent: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18>())).percent
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(percent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19 {
    pub type_: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19__bindgen_ty_1,
    pub pairing_info_len: cty::c_uint,
    pub pairing_info: [cty::c_char; 16usize],
}


pub type bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19__bindgen_ty_1 = cty::c_uint;
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>()))
                .pairing_info_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(pairing_info_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>())).pairing_info
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(pairing_info)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1>(),
        144usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).boot_unsafe as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(boot_unsafe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).appexitb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(appexitb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).appdel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(appdel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).appadd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(appadd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).upgrade as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(upgrade)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).ux_not_signed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(ux_not_signed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).run_app as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(run_app)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).customca_key as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(customca_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).foreign_key as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(foreign_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).reset_customca as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(reset_customca)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).setup_customca as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(setup_customca)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).keyboard as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(keyboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).validate_pin as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(validate_pin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).pin_keyboard as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(pin_keyboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).status_bar as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(status_bar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).loader as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(loader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).onboard as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(onboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).boot_delay as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(boot_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).pairing_request as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(pairing_request)
        )
    );
}
impl Default for bolos_ux_params_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s>(),
        152usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).ux_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(ux_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(u)
        )
    );
}
impl Default for bolos_ux_params_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type bolos_ux_params_t = bolos_ux_params_s;
extern "C" {
    pub fn os_perso_erase_all();
    pub fn os_perso_set_pin(identity: cty::c_uint, pin: *mut cty::c_uchar, length: cty::c_uint);
    pub fn os_perso_set_current_identity_pin(pin: *mut cty::c_uchar, length: cty::c_uint);
    pub fn os_perso_set_seed(
        identity: cty::c_uint,
        algorithm: cty::c_uint,
        seed: *mut cty::c_uchar,
        length: cty::c_uint,
    );
    pub fn os_perso_derive_and_set_seed(
        identity: cty::c_uchar,
        prefix: *const cty::c_char,
        prefix_length: cty::c_uint,
        passphrase: *const cty::c_char,
        passphrase_length: cty::c_uint,
        words: *const cty::c_char,
        words_length: cty::c_uint,
    );
    pub fn os_perso_set_words(words: *const cty::c_uchar, length: cty::c_uint);
    pub fn os_perso_finalize();
    pub fn os_perso_isonboarded() -> bolos_bool_t;
    pub fn os_perso_derive_node_bip32(
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
    );
    pub fn os_perso_derive_node_with_seed_key(
        mode: cty::c_uint,
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
        seed_key: *mut cty::c_uchar,
        seed_key_length: cty::c_uint,
    );
    pub fn os_perso_seed_cookie(
        seed_cookie: *mut cty::c_uchar,
        seed_cookie_length: cty::c_uint,
    ) -> cty::c_uint;
    pub fn os_endorsement_get_code_hash(buffer: *mut cty::c_uchar) -> cty::c_uint;
    pub fn os_endorsement_get_public_key(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
    pub fn os_endorsement_get_public_key_certificate(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
    pub fn os_endorsement_key1_get_app_secret(buffer: *mut cty::c_uchar) -> cty::c_uint;
    pub fn os_endorsement_key1_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
    pub fn os_endorsement_key2_derive_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
    pub fn os_global_pin_is_validated() -> bolos_bool_t;
    pub fn os_global_pin_check(
        pin_buffer: *mut cty::c_uchar,
        pin_length: cty::c_uchar,
    ) -> bolos_bool_t;
    pub fn os_global_pin_invalidate();
    pub fn os_global_pin_retries() -> cty::c_uint;
    pub fn os_registry_count() -> cty::c_uint;
    pub fn os_registry_get(index: cty::c_uint, out_application_entry: *mut application_t);
    pub fn os_ux(params: *mut bolos_ux_params_t) -> cty::c_uint;
    pub fn os_ux_result(params: *mut bolos_ux_params_t);
    pub fn os_ux_read_parameters(params: *mut bolos_ux_params_t);
    pub fn os_ux_blocking(params: *mut bolos_ux_params_t, arg1: *mut apdu_buffer_t) -> cty::c_uint;
    pub fn os_lib_call(call_parameters: *mut cty::c_uint);
    pub fn os_lib_end();
    pub fn os_lib_throw(exception: cty::c_uint);
    pub fn os_flags() -> cty::c_uint;
    pub fn os_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
    pub fn os_serial(serial: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
    pub fn os_seph_features() -> cty::c_uint;
    pub fn os_seph_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
    pub fn os_get_sn(buffer: *mut cty::c_uchar) -> cty::c_uint;
}

pub type os_setting_e = cty::c_uint;
pub use self::os_setting_e as os_setting_t;
extern "C" {
    pub fn os_setting_get(
        setting_id: cty::c_uint,
        value: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
    pub fn os_setting_set(setting_id: cty::c_uint, value: *mut cty::c_uchar, length: cty::c_uint);
    pub fn screen_printf(format: *const cty::c_char, ...);
    pub fn screen_printc(c: cty::c_uchar);
    pub fn snprintf(
        str_: *mut cty::c_char,
        str_size: cty::c_uint,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct meminfo_s {
    pub free_nvram_size: cty::c_uint,
    pub appMemory: cty::c_uint,
    pub systemSize: cty::c_uint,
    pub slots: cty::c_uint,
}
#[test]
fn bindgen_test_layout_meminfo_s() {
    assert_eq!(
        ::core::mem::size_of::<meminfo_s>(),
        16usize,
        concat!("Size of: ", stringify!(meminfo_s))
    );
    assert_eq!(
        ::core::mem::align_of::<meminfo_s>(),
        4usize,
        concat!("Alignment of ", stringify!(meminfo_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).free_nvram_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(free_nvram_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).appMemory as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(appMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).systemSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(systemSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).slots as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(slots)
        )
    );
}
pub type meminfo_t = meminfo_s;
extern "C" {
    pub fn os_get_memory_info(meminfo: *mut meminfo_t);
    pub fn os_registry_get_tag(
        appidx: cty::c_uint,
        tlvoffset: *mut cty::c_uint,
        tag: cty::c_uint,
        value_offset: cty::c_uint,
        buffer: *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
    pub fn os_registry_get_current_app_tag(
        tag: cty::c_uint,
        buffer: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
    pub fn os_customca_verify(
        hash: *mut cty::c_uchar,
        sign: *mut cty::c_uchar,
        sign_length: cty::c_uint,
    ) -> cty::c_uint;
    pub fn safe_desynch();
}

pub type os_watchdog_behavior_t = cty::c_uint;
extern "C" {
    pub fn os_watchdog_arm(useconds: cty::c_uint, behavior: os_watchdog_behavior_t);
    pub fn os_watchdog_value() -> cty::c_int;
}

pub type task_unsecure_id_e = cty::c_uint;
extern "C" {
    pub fn os_sched_exec(application_index: cty::c_uint);
    pub fn os_sched_exit(exit_code: bolos_task_status_t);
    pub fn os_sched_is_running(task_idx: cty::c_uint) -> bolos_bool_t;
    pub fn os_sched_last_status(task_idx: cty::c_uint) -> bolos_task_status_t;
    pub fn svc_os_sched_last_status(task_idx: cty::c_uint) -> bolos_task_status_t;
    pub fn os_sched_yield(status: bolos_task_status_t);
    pub fn svc_os_sched_yield(status: bolos_task_status_t);
    pub fn os_sched_switch(task_idx: cty::c_uint, status: bolos_task_status_t);
    pub fn svc_os_sched_switch(task_idx: cty::c_uint, status: bolos_task_status_t);
    pub fn os_sched_current_task() -> cty::c_uint;
    pub fn svc_os_sched_current_task() -> cty::c_uint;
    pub fn os_sched_create(
        permissions: cty::c_uint,
        main: *mut cty::c_void,
        nvram: *mut cty::c_void,
        nvram_length: cty::c_uint,
        ram0: *mut cty::c_void,
        ram0_length: cty::c_uint,
        ram1: *mut cty::c_void,
        ram1_length: cty::c_uint,
        stack: *mut cty::c_void,
        stack_length: cty::c_uint,
    ) -> cty::c_uint;
    pub fn os_sched_kill(taskidx: cty::c_uint);
    pub fn os_parse_bertlv(
        mem: *mut cty::c_uchar,
        mem_len: cty::c_uint,
        tlv_instance_offset: *mut cty::c_uint,
        tag: cty::c_uint,
        offset: cty::c_uint,
        buffer: *mut *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
